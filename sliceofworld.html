<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Slice-of-World Generator</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      @font-face {
        font-family: "unifontex";
        src: url("https://stgiga.github.io/UnifontEX/UnifontExMono.ttf");
        font-style: normal;
        font-weight: 400;
        font-display: block;
      }

      /* ====================== Sweetie16 (ONLY literal colors) ====================== */
      :root {
        --sw0: #1a1c2c;
        --sw1: #5d275d;
        --sw2: #b13e53;
        --sw3: #ef7d57;
        --sw4: #ffcd75;
        --sw5: #a7f070;
        --sw6: #38b764;
        --sw7: #257179;
        --sw8: #29366f;
        --sw9: #3b5dc9;
        --sw10: #41a6f6;
        --sw11: #73eff7;
        --sw12: #f4f4f4;
        --sw13: #94b0c2;
        --sw14: #566c86;
        --sw15: #333c57;

        /* ====================== App semantic vars ====================== */
        --bg: var(--sw0);
        --fg: var(--sw12);
        --mut: var(--sw13);
        --acc: var(--sw5);
        --btn: var(--sw15);
        --br: color-mix(in srgb, var(--sw12) 14%, transparent);

        --pane: var(--sw0);
        --pane2: color-mix(in srgb, black 40%, var(--sw0));
        --pill-bg: color-mix(in srgb, var(--sw0) 60%, var(--sw8));
        --pill-br: color-mix(in srgb, var(--sw7) 55%, transparent);

        /* cross-hover */
        --hot: var(--sw4);
        --hot-bg: color-mix(in srgb, var(--sw5) 14%, transparent);
        --hot-outline: color-mix(in srgb, var(--sw5) 28%, transparent);
        --ring: var(--sw5);

        /* ====================== Tile colors ====================== */
        --tile-water: var(--sw10);
        --tile-water-1: var(--sw10);
        --tile-water-2: var(--sw9);
        --tile-water-3: var(--sw8);

        --tile-mountain: var(--sw13);
        --tile-mountain-1: var(--sw13);
        --tile-mountain-2: var(--sw12);
        --tile-mountain-3: var(--sw12);
        --tile-mountain-4: var(--sw4);
        --tile-mountain-5: var(--sw11);

        --tile-forest: var(--sw6);
        --tile-forest-deciduous: var(--sw6);
        --tile-forest-coniferous: var(--sw7);
        --tile-forest-dead: color-mix(in srgb, var(--sw3) 40%, var(--sw1));

        --tile-grass: var(--sw6);
        --tile-plains: var(--sw15);
        --tile-settlement: var(--sw2);
        --tile-camp: var(--sw3);
        --tile-desert: var(--sw4);
      }

      html,
      body {
        height: 100%;
        display: flex;
        flex-direction: column;
        margin: 0;
        padding: 0;
        background: var(--bg);
        color: var(--fg);
        font-family: "unifontex", system-ui, Segoe UI, Roboto, Inter, sans-serif;
      }

      header {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem 1rem;
        align-items: center;
        padding: 12px;
        border-bottom: 1px solid var(--br);
      }

      h1 {
        font-size: 16px;
        margin: 0 12px 0 0;
        color: var(--acc);
      }

      label {
        color: var(--mut);
        font-size: 12px;
      }

      input,
      select,
      button {
        background: var(--btn);
        color: var(--fg);
        border: 1px solid var(--br);
        border-radius: 6px;
        padding: 7px 10px;
      }

      input[type="text"] {
        min-width: 10rem;
      }

      button {
        cursor: pointer;
      }

      button:active {
        transform: translateY(1px);
      }

      .wrap {
        flex-grow: 1;
        padding: 12px;
        display: flex;
        gap: 12px;
      }

      .pane {
        border: 1px solid var(--br);
        border-radius: 8px;
        padding: 10px;
        background: var(--pane2);
        position: relative;
        display: flex;
        gap: 1rem;
        flex-grow: 1;
      }

      .row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }

      pre {
        white-space: pre;
        overflow: auto;
        margin: 0;
        font-family: "unifontex", system-ui, Segoe UI, Roboto, Inter, sans-serif;
      }

      #out {
        flex: 1;
        text-wrap: balance;
      }

      #out .xref {
        text-decoration: underline;
        text-decoration-color: var(--mut);
        transition: all 0.15s ease-in-out;
      }
      #out .xref.is-hot {
        text-decoration: none;
      }

      .mapwrap {
        /* flex: 1; */
        display: flex;
        flex-direction: column;
        align-items: flex-end;
      }

      /* Larger, square-cell minimap */
      #map {
        margin-top: 8px;
        overflow: visible;
        cursor: pointer;
      }
      #map span {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        width: 1.2rem;
        height: 1.2rem;
        transition: all 0.15s ease-in-out;
        border-radius: 50%;
      }
      #map span:hover {
        transform: scale(1.3);
      }

      /* ========= Tile coloring (NO magic colors) ========= */
      #map span[data-tile="water"] {
        color: var(--tile-water);
      }
      #map span[data-tile="water"][data-depth="1"] {
        color: var(--tile-water-1);
      }
      #map span[data-tile="water"][data-depth="2"] {
        color: var(--tile-water-2);
      }
      #map span[data-tile="water"][data-depth="3"] {
        color: var(--tile-water-3);
      }

      #map span[data-tile="mountain"] {
        color: var(--tile-mountain);
      }
      #map span[data-tile="mountain"][data-height="1"] {
        color: var(--tile-mountain-1);
      }
      #map span[data-tile="mountain"][data-height="2"] {
        color: var(--tile-mountain-2);
      }
      #map span[data-tile="mountain"][data-height="3"] {
        color: var(--tile-mountain-3);
      }
      #map span[data-tile="mountain"][data-height="4"] {
        color: var(--tile-mountain-4);
      }
      #map span[data-tile="mountain"][data-height="5"] {
        color: var(--tile-mountain-5);
      }

      #map span[data-tile="forest"] {
        color: var(--tile-forest);
      }
      #map span[data-tile="forest"][data-forest="deciduous"] {
        color: var(--tile-forest-deciduous);
      }
      #map span[data-tile="forest"][data-forest="coniferous"] {
        color: var(--tile-forest-coniferous);
      }
      #map span[data-tile="forest"][data-forest="dead"] {
        color: var(--tile-forest-dead);
      }

      #map span[data-tile="grass"] {
        color: var(--tile-grass);
      }
      #map span[data-tile="plains"] {
        color: var(--tile-plains);
      }
      #map span[data-tile="settlement"] {
        color: var(--tile-settlement);
      }
      #map span[data-tile="camp"] {
        color: var(--tile-camp);
      }
      #map span[data-tile="desert"] {
        color: var(--tile-desert);
      }

      .small {
        font-size: 12px;
        color: var(--mut);
      }

      ul.list {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      ul.list li {
        background: var(--btn);
        border: 1px solid var(--br);
        padding: 4px 7px;
        border-radius: 6px;
        cursor: pointer;
      }
      ul.list li:hover {
        border-color: var(--acc);
      }

      .head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }
      .mut {
        color: var(--mut);
      }
      .sep {
        height: 10px;
      }

      .pill {
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid var(--br);
        background: var(--pill-bg);
      }
      .pill.seedpill {
        margin-top: 2rem;
      }
      .nowrap {
        white-space: nowrap;
      }
      .seedpill {
        margin-left: 6px;
        color: var(--fg);
        border-color: var(--pill-br);
        background: var(--pill-bg);
      }

      @media (max-width: 45rem) {
        .wrap {
          flex-direction: column;
        }
      }

      .hidden {
        display: none;
      }

      button.primary {
        background: color-mix(in srgb, var(--acc) 70%, var(--btn));
        color: var(--bg);
        font-weight: bold;
        transition: all ease-in-out 0.15s;
      }
      button.primary:hover {
        background: color-mix(in srgb, var(--acc) 80%, var(--btn));
      }

      /* ===== cross-hover linking ===== */
      #map span.is-hot {
        position: relative;
        transform-origin: center center;
        transform: scale(1.5);
      }
      #map span.is-hot::before {
        display: flex;
        height: 1.5rem;
        width: 1.5rem;
        border: 2px solid var(--ring);
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border-radius: 50%;
        background: var(--bg);
        z-index: -1;
        pointer-events: none;
      }

      #out .xref {
        cursor: pointer;
        border-radius: 4px;
        padding: 0 2px;
      }

      #out .xref.is-hot {
        color: var(--acc);
        background: var(--hot-bg);
        outline: 1px solid var(--hot-outline);
      }
    </style>
  </head>

  <body>
    <header>
      <h1>Slice-of-World</h1>
      <div class="row">
        <label for="seed">Seed</label>
        <input id="seed" type="text" placeholder="Leave blank for random" />
        <label for="theme">Theme</label>
        <select id="theme" class="nowrap" title="Theme">
          <option value="rnd">Random (seed-based)</option>
          <option value="fantasy">Fantasy</option>
          <option value="scifi">Sci-fi</option>
          <option value="apocalypse">Post-apocalyptic</option>
        </select>
        <button id="gen" class="primary">Generate</button>
        <button id="save" title="Add current seed to favorites">Save</button>
        <button id="prev">Prev</button>
        <button id="next">Next</button>
        <button id="copySeed" title="Copy current seed">Copy Seed</button>
        <button id="copyOut" title="Copy output text">Copy Output</button>
        <button id="share" title="Update URL with current seed/theme">Share</button>
      </div>
    </header>

    <div class="wrap">
      <div class="pane">
        <pre id="out"></pre>
        <span class="mapwrap">
          <pre id="map"></pre>
          <span class="pill seedpill small">
            Seed:
            <strong id="seedShow">â€”</strong>
          </span>
        </span>
      </div>

      <div class="hidden">
        <div class="head">
          <strong>History</strong><span class="small mut">(latest 5)</span>
        </div>
        <div id="histWrap">
          <ul id="hist" class="list"></ul>
        </div>
        <div class="sep"></div>
        <div class="head favs">
          <strong>Favorites</strong><button id="clrFav" class="pill small">Clear</button>
        </div>
        <ul id="favs" class="list"></ul>
        <div class="sep"></div>
        <div class="small mut">
          Tip: press <strong>Enter</strong> in the seed box to use that seed once.
        </div>
      </div>
    </div>

    <script>
      /* ====================== Tables (themes) ====================== */
      const T = {
        fantasy: {
          biome: [
            "tundra",
            "taiga",
            "temperate forest",
            "steppe",
            "savanna",
            "desert",
            "jungle",
            "wetlands",
            "highlands",
            "islands",
            "badlands",
          ],
          temp: {
            1: "gelid",
            2: "frigid",
            3: "chill",
            4: "mild",
            5: "warm",
            6: "balmy",
            7: "sultry",
            8: "searing",
          },
          rain: ["parched", "dry", "breezy", "misty", "drizzled", "rain-washed", "monsoonal", "storm-lashed"],
          climateAdj: [
            "rocky",
            "dusty",
            "foggy",
            "smoky",
            "cracked",
            "scarred",
            "shadowed",
            "glowing",
            "pitted",
            "overgrown",
            "mossy",
            "fungal",
            "boggy",
            "marshy",
            "rooted",
            "thorny",
            "brambly",
            "ancient",
            "veined",
            "twilight",
            "starlit",
            "moonlit",
            "buried",
            "forgotten",
          ],
          factionsN1: [
            "Order",
            "Guild",
            "Clan",
            "Court",
            "Circle",
            "Syndicate",
            "Chapter",
            "Coven",
            "Brotherhood",
            "Company",
            "League",
            "Consulate",
            "Caravan",
            "Enclave",
            "Assembly",
            "Dominion",
            "Conclave",
            "Pact",
            "Sect",
            "Keep",
            "Banner",
            "Throng",
            "Kin",
            "House",
            "Hollow",
            "Sanctum",
            "Forge",
            "Crusade",
            "March",
            "Host",
          ],
          factionsN2: ["of the", "of", "for the", "under", "against the", "beneath the", "among the", "beyond the", "within the", "beside the", "before the", "after the", "toward the", "upon the"],
          roles: [
            "Wardens",
            "Archivists",
            "Bonepickers",
            "Skyfarers",
            "Prospectors",
            "Scribes",
            "Wayfinders",
            "Stormcallers",
            "Reclaimers",
            "Oathkeepers",
            "Lamplighters",
            "Seers",
            "Witchbinders",
            "Lorehunters",
            "Pathmakers",
            "Gravetenders",
            "Runesmiths",
            "Beastwalkers",
            "Spellweavers",
            "Hearthguard",
            "Frostborn",
            "Flamebearers",
            "Thornwatch",
            "Miststriders",
          ],
          motives: [
            "guarding",
            "restoring",
            "cleansing",
            "protecting",
            "mapping",
            "exploring",
            "sealing",
            "unsealing",
            "harvesting",
            "reclaiming",
            "binding",
            "awakening",
            "silencing",
            "tending",
            "unlocking",
            "tracking",
            "defending",
            "consecrating",
            "studying",
            "excavating",
          ],
          motiveGlue: ["the only remaining", "a", "an ancient", "a forgotten", "a cursed", "the last", "a sacred", "a sealed", "an abandoned", "a hidden", "a buried", "a ruined", "a lost", "a reclaimed"],
          relicAdjectives: [
            "ancient",
            "forgotten",
            "sealed",
            "cracked",
            "hallowed",
            "bound",
            "runed",
            "sunken",
            "twilight",
            "blood-marked",
            "iron-bound",
            "frosted",
            "echoing",
            "cursed",
            "blessed",
            "hidden",
            "star-forged",
            "bone-carved",
          ],
          relicNouns: ["tablet", "idol", "scroll", "blade", "mask", "sigil", "key", "horn", "stone", "ring", "crown", "lens", "staff", "seal", "totem", "mirror", "lock", "gem", "vessel", "pendant"],
          pois: [
            "relic line",
            "forgotten cairn",
            "ley-thin path",
            "star-iron vein",
            "storm cycle",
            "dune-wyrm pact",
            "glowmoss field",
            "floodgate",
            "hearthhold",
            "shattered runestone",
            "cursed grove",
            "ancestral cairn",
            "rootbound enclave",
            "dormant sentinel",
            "echoing tomb",
            "emberfield",
            "sealed vault",
            "moonshade beast",
            "sky-bridge",
            "sunken sanctuary",
          ],
          weather: [
            "light wind",
            "fine dust in the air",
            "low thunder",
            "steady breeze",
            "scattered clouds",
            "brief gusts",
            "thin mist",
            "dry air",
            "occasional flashes",
            "soft rainfall",
            "distant rumble",
            "light haze",
            "static in the air",
            "drifting ash",
            "stillness before change",
            "faint crackling",
            "settling silt",
            "air thick with pollen",
            "cool drafts",
            "humid stillness",
          ],
          hooks: [
            "an oath breaks",
            "a relic goes missing",
            "a boundary marker is moved",
            "the river changes course",
            "the caravan doesn't arrive",
            "a ward stops working",
            "a beast emerges from the quarry",
            "a gate opens without warning",
            "a name is removed from the scrolls",
            "the harvest comes too early",
            "the flame marks someone new",
            "the map is altered",
            "a rival claims blood-right",
            "the tithe causes unrest",
            "the monolith sinks faster",
            "the plants react to movement",
            "a vault is uncovered",
            "the sky cracks at dawn",
            "a sigil appears",
            "the well runs dry",
          ],
          hookMods: ["near the <poi>", "within the biome", "during <weather> conditions", "beneath the <poi>", "around the <poi>", "when passing through the biome", "when the wind shifted to <weather>"],
          hookGlue: ["and", "but", "while", "as", "yet", "then", "though", "because", "when", "just as"],
        },

        scifi: {
          biome: ["oceanic world", "barren craters", "lava fields", "arboreal belts", "fungal mats", "erg desert", "ice shelf", "toxic bogs", "megacity sector", "ring habitat", "tidal wetlands"],
          temp: { 1: "cryonic", 2: "subzero", 3: "brisk", 4: "temperate", 5: "warm", 6: "tropic", 7: "equatorial", 8: "thermic" },
          rain: ["arid", "dry winds", "breezy", "humid", "mist-laden", "rainy", "storm-charged", "ion-saturated"],
          climateAdj: [
            "rocky",
            "dusty",
            "foggy",
            "smoky",
            "cracked",
            "scarred",
            "shadowed",
            "glowing",
            "pitted",
            "overgrown",
            "synthetic",
            "alien",
            "metallic",
            "magnetic",
            "gravitic",
            "orbital",
            "stellar",
            "lunar",
            "tidal",
            "crystalline",
            "coralline",
            "glassy",
            "mutant",
            "viral",
            "sentient",
            "abandoned",
            "encrypted",
            "rifted",
            "plasmatic",
          ],
          factionsN1: [
            "Consortium",
            "Syndicate",
            "Research Cell",
            "Freeport",
            "Colonial Office",
            "Outer Rim Guild",
            "Scavenger Crew",
            "Offworld Temple",
            "AI Collective",
            "Orbital Chapter",
            "Relay Cartel",
            "Trade Assembly",
            "Quantum Union",
            "Terraform Bureau",
            "Signal Corps",
            "Drift Network",
            "Cryo Division",
            "Echo Fleet",
            "Archive Node",
            "Security Cluster",
            "Mining Authority",
          ],
          factionsN2: ["of", "for", "operating in", "under", "over", "near", "within", "against", "aligned with", "based in"],
          roles: ["Surveyors", "Archivists", "Salvagers", "Datawrights", "Terraformers", "Smugglers", "Peacekeepers", "Prospectors", "Hackers", "Vigil AIs", "Skyfarers", "Signalers", "Cryotechs", "Synthbinders"],
          motives: [
            "guarding",
            "restoring",
            "studying",
            "protecting",
            "mapping",
            "exploring",
            "sealing",
            "unsealing",
            "harvesting",
            "reclaiming",
            "activating",
            "decrypting",
            "tracking",
            "repairing",
            "scanning",
            "hacking",
            "salvaging",
            "monitoring",
            "rebooting",
          ],
          motiveGlue: ["the only remaining", "a", "an old", "a sealed", "a forgotten", "a derelict", "a hidden", "an encrypted"],
          relicAdjectives: ["encrypted", "forgotten", "sealed", "quantum", "bio-locked", "holographic", "corrupted", "archived"],
          relicNouns: ["core", "drive", "node", "key", "vault", "chip", "beacon", "archive", "relay", "protocol"],
          pois: ["orbital spine", "seed vault", "phase-burned crater", "maglev trench", "signal relay", "data vault", "drift station"],
          weather: ["static rain", "an ion flash", "dust drift", "signal interference", "electrical haze", "solar flare scatter"],
          hooks: ["a ghost ping repeats each dusk", "a vault opens for the first time", "a comms blackout spreads", "a relay node reboots unexpectedly", "a drone fails to report", "a beacon activates without command"],
          hookMods: ["near the <poi>", "inside the <poi>", "during <weather>", "as <weather> builds", "after <weather> clears"],
          hookGlue: ["and", "but", "while", "as", "yet", "then", "though", "because", "even as", "just as"],
        },

        apocalypse: {
          biome: ["ruined city", "wasteland", "overgrowth", "floodplain", "ash desert", "irradiated zone", "salt flats", "scrapyard dunes", "bunker valley", "shattered highlands", "canal maze"],
          temp: { 1: "frost-bit", 2: "cold", 3: "cool", 4: "mild", 5: "warm", 6: "hot", 7: "blistering", 8: "oven-hot" },
          rain: ["powder-dry", "dry gusts", "dusty", "clammy", "drizzle", "rain-battered", "monsoon-bent", "electric storms"],
          climateAdj: [
            "rocky",
            "dusty",
            "foggy",
            "smoky",
            "cracked",
            "scarred",
            "shadowed",
            "glowing",
            "pitted",
            "overgrown",
            "sooty",
            "ashen",
            "shattered",
            "rusted",
            "abandoned",
            "buried",
            "sealed",
            "forgotten",
            "viral",
            "mutant",
            "slimed",
            "broken",
            "ruined",
            "hollow",
          ],
          factionsN1: ["Remnants", "Road Kings", "Canal Commune", "Vault Kin", "Scrap Choir", "Spore Ward", "Signal House"],
          factionsN2: ["of", "at", "over", "under", "through", "against", "within", "near", "beyond", "inside", "along", "beneath"],
          roles: ["Scavvers", "Archivists", "Pickers", "Claimants", "Watchers", "Riggers", "Spanners", "Guides", "Slingers"],
          motives: ["guarding", "claiming", "mining", "fighting", "hoarding", "charting", "towing", "sealing", "trading", "repairing"],
          motiveGlue: ["the only remaining", "a", "an old", "a sealed", "a flooded", "a broken", "a buried", "a rusted", "a forgotten"],
          relicAdjectives: ["sealed", "rusted", "burned", "coded", "scrapped", "buried", "cracked", "patched", "irradiated", "forgotten"],
          relicNouns: ["vault", "badge", "drive", "mask", "chip", "tag", "key", "module", "canister", "token", "seal", "crate"],
          pois: ["interchange", "metro mouth", "signal tower", "mall", "canal gate", "rail cathedral", "salt pit", "water plant"],
          weather: ["static rain", "brown snow", "heat shimmer", "metallic drizzle", "smoke squalls", "acid mist", "radio interference"],
          hooks: ["a treaty flag burns", "a convoy goes missing", "a bunker door opens on its own", "a warning light blinks without power", "a flare goes up with no claim"],
          hookMods: ["near the <poi>", "inside the <poi>", "during <weather>", "as <weather> builds", "after <weather> clears"],
          hookGlue: ["and", "but", "while", "as", "yet", "then", "though", "because", "even as", "just as"],
        },
      };
            
      const NPC_TASKS = {
        faction: [
          "recruiting new members for a difficult assignment",
          "screening applicants after a recent breach",
          "guarding a cache of supplies near <poi>",
          "guarding a sealed storehouse whose lock has begun to fail",
          "escorting a courier between safehouses",
          "escorting a dignitary through contested ground",
          "training new initiates in protocol and discipline",
          "drilling a response team for an expected incursion",
          "auditing relics, records, and inventories for discrepancies",
          "investigating forged credentials circulating among allies",
          "negotiating a fragile truce over access to <poi>",
          "enforcing a disputed boundary marker near <poi>",
          "recovering a stolen insignia tied to leadership authority",
          "hunting an infiltrator who knows internal routes",
          "coordinating a joint operation with an uneasy partner",
          "planning a raid or recovery mission timed with <weather>",
          "intercepting contraband moving through the biome",
          "protecting a witness scheduled to testify at a council",
          "relocating a vulnerable cell before the next crackdown",
          "disabling a rival outpost overlooking <poi>",
          "repairing a failing ward, gate, lock, or access point",
          "attempting to reactivate a dormant asset at <poi>",
          "silencing rumors that could fracture the ranks",
          "delivering an ultimatum to a rival faction",
          "hosting a tribunal for a member accused of betrayal",
          "tracking a missing squad last seen near <poi>",
          "securing a route for a coming convoy",
          "mapping contacts and loyalties inside a contested district",
          "recovering a lost map that details hidden approaches",
          "testing a prototype tool or ritual under field conditions",
          "containing an outbreak of panic after <weather>",
          "negotiating trade rights in exchange for protection",
          "redistributing rations after an unexpected shortage",
          "guarding a prisoner transfer through hostile ground",
          "searching for a specialist needed to stabilize <poi>",
          "tending a wounded leader while rivals circle",
          "covering up a mistake before it becomes public",
          "investigating a sabotage incident in the faction's stores",
          "retrieving a message that must not be read by outsiders",
          "binding, sealing, or securing a dangerous discovery at <poi>",
          "monitoring a repeating signal/omen tied to <poi>",
          "setting a trap for a rival team operating near <poi>",
          "running security for a clandestine meeting during <weather>",
          "conducting a census of members and dependents",
          "escorting a defector who wants asylum",
          "protecting a critical shipment during <weather>",
          "investigating why a long-trusted contact went silent",
          "clearing a safehouse compromised by an unknown contaminant",
        ],

        settlement: [
          "repairing the waterworks after <weather>",
          "patching leaks and reinforcing cisterns ahead of <weather>",
          "restoring power/heat/light to a key block of homes",
          "fixing a jammed gate, lift, lock, or access mechanism",
          "tracking a series of thefts that target essentials",
          "investigating a break-in at a storeroom near <poi>",
          "organizing a trade caravan and negotiating safe passage",
          "preparing a ration exchange with an unreliable partner",
          "hosting a tense council meeting about <poi>",
          "mediating a feud that threatens to split the community",
          "surveying new housing sites away from known hazards",
          "mapping structural risks in older tunnels/buildings",
          "investigating a strange illness spreading after <weather>",
          "quarantining a block and tracing the source to <poi>",
          "clearing rubble to reopen a route to <poi>",
          "reinforcing defenses after a warning sign at <poi>",
          "training volunteers for watch duty and emergency response",
          "rescuing trapped workers during <weather>",
          "finding a replacement part/resource the settlement can't do without",
          "recovering a lost tool kit critical to maintenance",
          "auditing stores because supplies don't match the ledgers",
          "running a controlled burn / purge / cleanup of a contaminated zone",
          "investigating a suspicious fire that started too cleanly",
          "negotiating a marriage pact / adoption / sponsorship to secure alliances",
          "settling a land claim dispute over the edge of the biome",
          "evacuating families after a new hazard appears near <poi>",
          "escorting a visiting envoy through nervous streets",
          "hosting a ceremony that must not be interrupted",
          "burying the dead and appeasing the living after a tragedy",
          "repairing communications lines after <weather>",
          "tracking why patrols keep missing check-ins near <poi>",
          "building a new market route that avoids a dangerous stretch",
          "shoring up walls and walkways before the next <weather>",
          "investigating counterfeit tokens, ration chits, or permits",
          "hunting down a black-market supplier poisoning the town",
          "organizing a salvage lottery that's turning violent",
          "recovering a child/elder who wandered toward <poi>",
          "escorting healers/engineers to a worksite near <poi>",
          "replacing leadership after a sudden resignation",
          "investigating a ghost story that's driving people away from <poi>",
          "securing a festival with rising tensions and hidden weapons",
          "disarming a booby trap found in a common thoroughfare",
          "patching a collapsed tunnel/bridge caused by <weather>",
          "moving the seed stores / archives / reliquary to a safer vault",
          "interviewing newcomers whose story doesn't add up",
          "negotiating protection payments under threat",
          "tracking a predator that hunts livestock near <poi>",
          "testing a new well/route that may be cursed/unsafe/unstable",
          "restoring the local map after someone altered it",
        ],

        world: [
          "mapping an unmapped trail that skirts <poi>",
          "charting safe routes as <weather> builds",
          "guiding travelers through hostile ground to <poi>",
          "escorting pilgrims, refugees, or traders across the biome",
          "hunting a dangerous creature seen near <poi>",
          "tracking something that leaves no prints after <weather>",
          "recovering a lost expedition last seen near <poi>",
          "searching for a missing scout who vanished during <weather>",
          "salvaging a ruined site for usable parts and supplies",
          "extracting valuable material from a hazardous zone near <poi>",
          "scouting a rival camp positioned near <poi>",
          "observing an encroaching force without being detected",
          "securing a crossing after the terrain shifts near <poi>",
          "repairing a broken bridge, lift, or passageway at <poi>",
          "investigating why an old marker no longer matches the land",
          "following a repeating signal/omen that points toward <poi>",
          "closing, sealing, or stabilizing a breach at <poi>",
          "unsealing a site at <poi> under strict precautions",
          "retrieving a relic/container/data-cache rumored to be in <poi>",
          "delivering a message through a zone nobody wants to cross",
          "recovering a downed cart/sled/rig stranded by <weather>",
          "clearing a path through overgrowth, rubble, or drifted dunes",
          "setting up a remote observation post overlooking <poi>",
          "testing whether the water/air/soil is safe beyond the ridge",
          "tracking a poacher or scavenger crew operating near <poi>",
          "negotiating passage with a territorial group beyond the border",
          "discovering why local wildlife avoids <poi>",
          "finding the source of strange lights/sounds near <poi>",
          "recovering supplies dropped during a retreat",
          "investigating an abandoned camp where everything was left behind",
          "locating a hidden cache mapped only in partial coordinates",
          "escorting a specialist needed to handle <poi>",
          "running a diversion to pull attention away from <poi>",
          "delivering emergency medicine to an isolated outpost",
          "surveying terrain for a future settlement site",
          "finding fresh water in a parched stretch of the biome",
          "tracking the movement of a storm front that behaves wrongly",
          "recovering a stolen map and identifying who copied it",
          "investigating a boundary marker that was moved overnight",
          "following a trail of messages carved/encoded along the route",
          "retrieving proof of a rival's wrongdoing from <poi>",
          "rescuing captives taken toward <poi>",
          "destroying a hazard source without triggering worse consequences",
          "confirming whether <poi> is truly empty or merely silent",
          "bringing back a sample/artifact from <poi> without contamination",
          "finding a safer detour after <weather> makes the main route impassable",
          "tracking a caravan that never arrived from the direction of <poi>",
          "retrieving a lost heirloom that may start a war if mishandled",
          "investigating a new sinkhole/collapse revealed after <weather>",
        ],
      };


      const SYL = ["al", "ur", "da", "ri", "ka", "lem", "vor", "zan", "ti", "sha", "mor", "bel", "oth", "ryn", "ser", "vak", "nel", "ios", "qar", "ume", "thal", "gre", "nor", "fen", "zir", "una", "vek", "cal", "mar", "ros", "ion", "kha", "zul", "ora", "sta", "dra", "pha"];

      const namePost = [" Hold", " Castle", " Reach", " Fall", " Falls", " Gate", " Prime", " Camp", " Cliffs", " Fold", " Crown", " Wilds", " Hollow", " Vale", " Peaks", " Grove", " Keep", " Commune", " Verge", " Wastes", " Spire", " Fields", " Flats", " Basin", " Spine", " Fault", " Deep", " Steppe", " Maw", " Province"];

      /* ====================== Tileset (no colors here; CSS drives colors) ====================== */
      const tileset = {
        water: { depthGlyphs: { 1: "~", 2: "â‰ˆ", 3: "â‰‹" } },
        plains: { tile: "Â·", variants: ["â€§", "âˆ™"] },
        grass: { tile: "áµž", variants: ["áµž", "Ë¯", "Ë¬", "Ë‡", "â€¦", "âµˆ", '"', "'"] },
        forest: {
          tile: "â¯­",
          coniferous: ["âƒ", "ð™¢", "ðŠ¾"],
          dead: ["ð™˜", "â†‘", "â†Ÿ"],
          deciduous: ["ðŒ’", "á»Œ"],
          variants: ["ð™˜", "â†‘", "âƒ", "ðŒ’", "á»Œ", "ð™¢", "ðŠ¾", "â†Ÿ"],
        },
        desert: { tile: "â‰ˆ", variants: ["â‰ˆ", "â‰‹"] },
        mountain: {
          tile: "^",
          height: { 1: "^", 2: "á¨ˆ", 3: "âˆ§", 4: "Î›", 5: "ð˜ " },
          variants: ["Ë„", "Î›", "âˆ§", "ð˜ ", "âŒƒ", "á¨ˆ"],
        },
        settlement: { tile: "â›©", variants: ["âŒ‚", "ð˜®", "ð™", "ð›…", "ð›˜", "ð¡", "ð€", "ð", "ð‚§", "ðƒ€"] },
        camp: { tile: "á—‘" },
      };

      /* ====================== Deterministic Core ====================== */
      function h32(s) {
        let h = 5381 >>> 0;
        for (let i = 0; i < s.length; i++) h = ((h * 33) ^ s.charCodeAt(i)) >>> 0;
        return h >>> 0;
      }

      function xs32(seed) {
        let x = seed >>> 0;
        return () => {
          x ^= x << 13;
          x ^= x >>> 17;
          x ^= x << 5;
          return (x >>> 0) / 4294967296;
        };
      }

      function n2(seed, x, y) {
        let v = (seed ^ ((x * 374761393) | 0) ^ ((y * 668265263) | 0)) >>> 0;
        v ^= v >>> 13;
        v = Math.imul(v, 1274126177) >>> 0;
        v ^= v >>> 16;
        return (v >>> 0) / 4294967296;
      }

      function randSeed() {
        const a = new Uint32Array(1);
        if (crypto && crypto.getRandomValues) crypto.getRandomValues(a);
        else a[0] = (Math.random() * 4294967296) >>> 0;
        return a[0].toString(36);
      }

      class NameGenerator {
        constructor(rng, { syllables = SYL, postfixes = namePost } = {}) {
          this.r = rng;
          this.syllables = syllables;
          this.postfixes = postfixes;
        }

        baseName({ allowExtraSyllable = true } = {}) {
          const n = 2 + (allowExtraSyllable && this.r() > 0.7);
          let s = "";
          for (let i = 0; i < n; i++) s += this.syllables[(this.r() * this.syllables.length) | 0];
          return s.charAt(0).toUpperCase() + s.slice(1);
        }

        placeName() {
          let s = this.baseName();
          if (this.r() > 0.5) s += this.postfixes[(this.r() * this.postfixes.length) | 0];
          return s;
        }

        npcName() {
          return this.baseName();
        }
      }

      function oneOf(r, src) {
        if (!src) return undefined;
        if (Array.isArray(src)) return src[(r() * src.length) | 0];
        if (typeof src === "object") {
          const keys = Object.keys(src);
          if (!keys.length) return undefined;
          const k = keys[(r() * keys.length) | 0];
          return src[k];
        }
        return src;
      }

      function maybe(rng, chance = 0.5) {
        return typeof rng === "function" ? rng() < chance : Math.random() < chance;
      }

      /* ====================== Climate pick ====================== */
      function pickTempTier(r, tt) {
        const temp = tt?.temp;
        if (temp && typeof temp === "object" && !Array.isArray(temp)) {
          const keys = Object.keys(temp)
            .map((k) => Number(k))
            .filter((n) => Number.isFinite(n))
            .sort((a, b) => a - b);
          if (keys.length) {
            const tier = keys[(r() * keys.length) | 0];
            return { tier, label: String(temp[tier]) };
          }
        }
        const label = oneOf(r, temp) ?? "mild";
        return { tier: 4, label: String(label) };
      }

      function pickRainIndex(r, tt) {
        const rain = tt?.rain;
        if (Array.isArray(rain) && rain.length) {
          const idx = (r() * rain.length) | 0;
          return { idx, label: String(rain[idx]) };
        }
        const label = oneOf(r, rain) ?? "dry";
        return { idx: 1, label: String(label) };
      }

      /* ====================== Faction naming (fixed deterministic lexicon) ====================== */
      const DEFAULT_COLLECTIVES = ["Order", "Guild", "Clan", "Court", "Circle", "Syndicate", "Chapter", "Coven", "Brotherhood", "Company", "League", "Consulate", "Caravan", "Enclave", "Assembly", "Dominion", "Conclave", "Pact", "Sect", "Keep", "Banner", "Kin", "House", "Hollow", "Sanctum", "Forge", "Crusade", "March", "Host"];
      const DEFAULT_ROLES = ["Wardens", "Archivists", "Bonepickers", "Skyfarers", "Prospectors", "Scribes", "Wayfinders", "Stormcallers", "Reclaimers", "Oathkeepers", "Lamplighters", "Seers", "Witchbinders", "Lorehunters", "Pathmakers", "Gravetenders", "Runesmiths", "Beastwalkers", "Spellweavers", "Hearthguard", "Frostborn", "Flamebearers", "Thornwatch", "Miststriders"];

      function ensure(arr, fallback) {
        return Array.isArray(arr) && arr.length ? arr : fallback;
      }

      function uniqN(n, fn) {
        const out = new Set();
        let guard = 0;
        while (out.size < n && guard++ < n * 20) out.add(fn());
        return Array.from(out);
      }

      function cartesian(a, b) {
        const out = [];
        for (let i = 0; i < a.length; i++) for (let j = 0; j < b.length; j++) out.push([a[i], b[j]]);
        return out;
      }

      function pickWeighted(r, items) {
        const sum = items.reduce((acc, it) => acc + (it.weight || 1), 0);
        const roll = r() * sum;
        let acc = 0;
        for (const it of items) {
          acc += it.weight || 1;
          if (roll < acc) return it;
        }
        return items[items.length - 1];
      }

      function buildLineages(r, count = 12) {
        const roots = ["Var", "Tor", "Ash", "Hale", "Brenn", "Keth", "Mor", "Vale", "Dun", "Rav", "Fen", "Grey", "Orv", "Nyx", "Cal"];
        const suf = ["yn", "ell", "ath", "ek", "ar", "os", "en", "ard", "ir", "an", "oth", "ic", "as"];
        return uniqN(count, () => roots[(r() * roots.length) | 0] + suf[(r() * suf.length) | 0]);
      }

      function buildToponyms(r, count = 20) {
        const roots = ["Ash", "Red", "Thorn", "Hollow", "River", "Stone", "Mist", "Oak", "Wolf", "Raven", "Sun", "Star", "Ember", "Frost", "Gold", "Mire", "Holt", "Rev", "Shale", "Writ"];
        const suf = ["mere", "holt", "gate", "brig", "brook", "field", "wood", "veld", "keep", "bridge", "ward", "reach", "shire", "watch", "march", "moor", "ford", "fell", "crest", "vale", "dell", "dale", "fen", "scythe", "glen", "ryn"];
        return uniqN(count, () => roots[(r() * roots.length) | 0] + suf[(r() * suf.length) | 0]);
      }

      function buildRegionsFromToponyms(r, tops, count = 10, regionizer_chance = 0.5) {
        const regionizers = ["Low", "Upper", "High", "Outer", "Far", "Near", "Old", "New"];
        const plurals = ["Marches", "Hills", "Moors", "Flats", "Wastes", "Reaches", "Wards", "Downs"];
        return uniqN(count, () => {
          const top = tops[(r() * tops.length) | 0];
          const addRegionizer = r() < regionizer_chance;
          const addPlural = r() < 0.4;
          const rr = regionizers[(r() * regionizers.length) | 0];
          const prefix = addRegionizer ? rr + " " : "";
          if (addPlural) {
            const p = plurals[(r() * plurals.length) | 0];
            return `${prefix}${top} ${p}`;
          }
          return `${prefix}${top}`;
        });
      }

      function buildNicknames(r) {
        const colors = ["Black", "Red", "Grey", "White", "Gold", "Green", "Blue", "Umber", "Sable", "Crimson", "Azure"];
        const things = ["Thorn", "Hand", "Lantern", "Crow", "Hound", "Spear", "Moth", "Mason", "Key", "Hammer", "Watch"];
        return cartesian(colors, things).map(([c, t]) => `${c} ${t}${maybe(r, 0.5) ? "s" : ""}`);
      }

      const TEMPLATES = [
        { name: "Title+Lineage", weight: 12, build: (r, L) => `${oneOf(r, L.titles)} ${oneOf(r, L.lineages)}` },
        { name: "Title+Toponym", weight: 6, build: (r, L) => `${oneOf(r, L.titles)} ${oneOf(r, L.toponyms)}` },
        { name: "The+Collective+of+Role", weight: 16, build: (r, L) => `The ${oneOf(r, L.collectives)} ${oneOf(r, L.prepsOf)} ${oneOf(r, L.roles)}` },
        { name: "Role+of+Toponym", weight: 14, build: (r, L) => `${oneOf(r, L.roles)} ${oneOf(r, L.prepsOf)} ${oneOf(r, L.toponyms)}` },
        { name: "The+Collective+of+Toponym", weight: 12, build: (r, L) => `The ${oneOf(r, L.collectives)} ${oneOf(r, L.prepsOf)} ${oneOf(r, L.toponyms)}` },
        { name: "Abstract+of+Region", weight: 10, build: (r, L) => `${oneOf(r, L.abstracts)} ${oneOf(r, L.prepsOf)} ${oneOf(r, L.regions)}` },
        { name: "Toponym+Company", weight: 8, build: (r, L) => `${oneOf(r, L.toponyms)} ${oneOf(r, L.tradeBodies)}` },
        { name: "The+Nickname", weight: 7, build: (r, L) => `The ${oneOf(r, L.nicknames)}` },
        { name: "Hybrid", weight: 9, build: (r, L) => `${oneOf(r, L.titles)} ${oneOf(r, L.lineages)} ${oneOf(r, L.prepsOf)} ${oneOf(r, L.toponyms)}` },
        { name: "Role+Preposition+Site", weight: 6, build: (r, L) => `${oneOf(r, L.roles)} ${oneOf(r, L.prepsSite)} ${oneOf(r, L.sites)}` },
      ];

      function buildLexicon(tt, r) {
        const roles = ensure(tt.roles, DEFAULT_ROLES);
        const collectives = ensure(tt.factionsN1, DEFAULT_COLLECTIVES);

        const prepsOf = ["of", "of the"];
        const prepsSite = ["at", "under", "within", "beside", "along", "near"];

        const abstracts = ["Pact", "Dominion", "March", "Compact", "Confederacy", "Concord", "Mandate", "League", "Charter"];
        const tradeBodies = ["Company", "Charter", "Shipping", "Freight", "Exchange", "Syndicate", "Cartage"];
        const titles = ["House", "Clan", "Order", "Circle", "Court", "Conclave", "Banner", "Keep", "Forge", "Sanctum", "Host"];

        const lineages = buildLineages(r, 12);
        const toponyms = buildToponyms(r, 20);
        const regions = buildRegionsFromToponyms(r, toponyms, 10);
        const nicknames = buildNicknames(r);

        const sitesBase = ["Gate", "Bridge", "Wayhouse", "Watch", "Spire", "Hollow", "Vault", "Crossing", "Ford", "Hall", "Tower", "Works"];
        const sites = sitesBase.map((s) => (maybe(r, 0.5) ? `the ${s}` : s));

        return { roles, collectives, prepsOf, prepsSite, abstracts, tradeBodies, titles, lineages, toponyms, regions, nicknames, sites };
      }

      function factionName(r, theme = "fantasy") {
        const tt = T[theme] || {};
        const L = buildLexicon(tt, r);
        const template = pickWeighted(r, TEMPLATES);
        return template.build(r, L);
      }

      /* ====================== World/Text â†” Map Consistency Helpers ====================== */
      function escAttr(s) {
        return String(s)
          .replace(/&/g, "&amp;")
          .replace(/"/g, "&quot;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }

      function escHtml(s) {
        return String(s).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }

      function escRe(s) {
        return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }

      function xref(cell, label) {
        return `<span class="xref" data-cell="${escAttr(cell)}">${escHtml(label)}</span>`;
      }

      function shuffleDet(r, arr) {
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--) {
          const j = (r() * (i + 1)) | 0;
          [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
      }

      function namedPOI(nameGen, poiType) {
        const r = nameGen.r;
        const style = (r() * 4) | 0;
        const base = nameGen.placeName();
        if (style === 0) return `${base} ${poiType}`;
        if (style === 1) return `The ${poiType} of ${base}`;
        if (style === 2) return `${poiType.charAt(0).toUpperCase() + poiType.slice(1)} at ${base}`;
        return `${base}'s ${poiType}`;
      }

      function buildSettlementNames(nameGen, count) {
        return uniqN(count, () => nameGen.placeName());
      }

      function placeWorldRefs(seedU32, theme, tileKeyGrid, N, poiTypes, factions, rText) {
        const r = xs32(seedU32 ^ 0xa53c9e17);

        const settlements = [];
        const land = [];

        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            const k = tileKeyGrid[y][x];
            const key = `${x},${y}`;
            if (k !== "water") land.push(key);
            if (k === "settlement") settlements.push(key);
          }
        }

        const settlementOrder = shuffleDet(r, settlements);
        const landOrder = shuffleDet(r, land);

        const nameGen = new NameGenerator(rText);
        const settlementNames = buildSettlementNames(nameGen, Math.max(6, settlements.length));
        const settlementNameByCell = new Map();
        settlements.forEach((cell, i) => settlementNameByCell.set(cell, settlementNames[i % settlementNames.length]));

        const poiPlacements = [];
        for (let i = 0; i < poiTypes.length; i++) {
          const poiType = poiTypes[i];
          const poiName = namedPOI(nameGen, poiType);

          const cell = settlementOrder[i] || landOrder[i] || `${(seedU32 % N) | 0},${((seedU32 >>> 8) % N) | 0}`;
          poiPlacements.push({ poiType, poiName, cell });
        }

        const used = new Set(poiPlacements.map((p) => p.cell));
        const factionPlacements = [];

        let sIdx = poiTypes.length;
        let lIdx = poiTypes.length;

        for (let i = 0; i < factions.length; i++) {
          let cell = null;

          while (sIdx < settlementOrder.length && used.has(settlementOrder[sIdx])) sIdx++;
          if (sIdx < settlementOrder.length) cell = settlementOrder[sIdx++];

          if (!cell) {
            while (lIdx < landOrder.length && used.has(landOrder[lIdx])) lIdx++;
            cell = landOrder[lIdx++] || landOrder[0] || `${i % N},${(i * 7) % N}`;
          }

          used.add(cell);
          factionPlacements.push({ factionName: factions[i].name, motive: factions[i].motive, cell });
        }

        const ann = new Map();
        function ensureCell(cell) {
          if (!ann.has(cell)) ann.set(cell, { poi: [], factions: [] });
          return ann.get(cell);
        }

        for (const cell of settlements) {
          const o = ensureCell(cell);
          o.settlementName = settlementNameByCell.get(cell);
        }

        for (const p of poiPlacements) {
          const o = ensureCell(p.cell);
          o.poi.push({ name: p.poiName, type: p.poiType });
        }

        for (const f of factionPlacements) {
          const o = ensureCell(f.cell);
          o.factions.push({ name: f.factionName });
          if (!settlementNameByCell.has(f.cell)) o.fieldCamp = true;
        }

        return { annotations: ann, poiPlacements, factionPlacements, settlementNameByCell };
      }

      /* ====================== ASCII Map ====================== */
      function tileWeightsForBiome(biome) {
        const baseWeights = { water: 0.12, mountain: 0.15, forest: 0.25, grass: 0.2, plains: 0.28 };
        const inc = (k, f) => (baseWeights[k] = Math.max(0.01, baseWeights[k] * f));
        const s = biome.toLowerCase();

        if (s.includes("desert") || s.includes("erg") || s.includes("salt")) {
          inc("plains", 2.2);
          inc("forest", 0.5);
          inc("grass", 0.6);
          inc("water", 0.4);
          inc("mountain", 0.7);
        }
        if (s.includes("jungle") || s.includes("arboreal") || s.includes("overgrowth") || s.includes("fungal")) {
          inc("forest", 1.9);
          inc("grass", 1.4);
          inc("plains", 0.7);
          inc("water", 1.2);
          inc("mountain", 0.8);
        }
        if (s.includes("wetland") || s.includes("bog") || s.includes("flood") || s.includes("canal")) {
          inc("water", 2.2);
          inc("grass", 1.5);
          inc("forest", 1.2);
          inc("plains", 0.7);
        }
        if (s.includes("island") || s.includes("oceanic") || s.includes("tidal") || s.includes("ring habitat")) {
          inc("water", 2.4);
          inc("forest", 0.9);
          inc("grass", 0.9);
          inc("plains", 0.7);
          inc("mountain", 0.6);
        }
        if (s.includes("highland") || s.includes("mount") || s.includes("shattered") || s.includes("ice shelf")) {
          inc("mountain", 2.0);
          inc("plains", 1.2);
          inc("forest", 0.9);
          inc("grass", 0.9);
        }
        if (s.includes("barren") || s.includes("ruin") || s.includes("ruined") || s.includes("wasteland") || s.includes("megacity") || s.includes("scrapyard") || s.includes("lava")) {
          inc("plains", 1.6);
          inc("forest", 0.8);
          inc("grass", 0.7);
          inc("mountain", 1.1);
          inc("water", 0.9);
        }

        const total = Object.values(baseWeights).reduce((a, b) => a + b, 0);
        for (const k in baseWeights) baseWeights[k] /= total;
        return baseWeights;
      }

      function pickByWeights(x, weights) {
        const keys = Object.keys(weights);
        let acc = 0;
        for (let i = 0; i < keys.length; i++) {
          const k = keys[i];
          acc += weights[k];
          if (x <= acc) return k;
        }
        return keys[keys.length - 1];
      }

      function pickVariant(tileKey, tileset, seed) {
        const variants = [tileset[tileKey].tile, ...(tileset[tileKey].variants || [])];
        const index = Math.floor(seed * variants.length);
        return variants[index];
      }

      function riverCells(seedU32, N) {
        const cells = new Set();
        let x = (seedU32 % N) | 0;
        for (let y = 0; y < N; y++) {
          const drift = n2(seedU32, 9000 + y, 9100 + y);
          if (drift < 0.33) x = Math.max(0, x - 1);
          else if (drift > 0.66) x = Math.min(N - 1, x + 1);
          cells.add(`${x},${y}`);
          if (x > 0) cells.add(`${x - 1},${y}`);
          if (x < N - 1) cells.add(`${x + 1},${y}`);
        }
        return cells;
      }

      function biomeAllowsRiver(biome) {
        const s = biome.toLowerCase();
        return s.includes("wetland") || s.includes("flood") || s.includes("river") || s.includes("jungle") || s.includes("forest") || s.includes("temperate") || s.includes("savanna");
      }

      /* ====================== Shared grid helpers ====================== */
      function clamp(v, lo, hi) {
        return Math.max(lo, Math.min(hi, v));
      }

      function neighbors4(N, x, y) {
        const out = [];
        if (y > 0) out.push([x, y - 1]);
        if (x < N - 1) out.push([x + 1, y]);
        if (y < N - 1) out.push([x, y + 1]);
        if (x > 0) out.push([x - 1, y]);
        return out;
      }

      function neighbors8(N, x, y) {
        const out = [];
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = x + dx,
              ny = y + dy;
            if (nx >= 0 && ny >= 0 && nx < N && ny < N) out.push([nx, ny]);
          }
        }
        return out;
      }

      function countNeighbors8Of(tileKeyGrid, N, x, y, key) {
        let c = 0;
        for (const [nx, ny] of neighbors8(N, x, y)) if (tileKeyGrid[ny][nx] === key) c++;
        return c;
      }

      function countWaterNeighbors4(tileKeyGrid, N, x, y) {
        const neigh = neighbors4(N, x, y);
        let c = 0;
        for (const [nx, ny] of neigh) if (tileKeyGrid[ny][nx] === "water") c++;
        return c;
      }

      function cleanupIsolatedWater(seedU32, tileKeyGrid, weights, N) {
        const next = tileKeyGrid.map((row) => row.slice());
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "water") continue;
            if (countWaterNeighbors4(tileKeyGrid, N, x, y) !== 0) continue;

            const cand = new Map();
            for (const [nx, ny] of neighbors4(N, x, y)) {
              const k = tileKeyGrid[ny][nx];
              if (!k || k === "water" || k === "settlement") continue;
              cand.set(k, (cand.get(k) || 0) + 1);
            }

            let replacement = null;

            if (cand.size) {
              const entries = Array.from(cand.entries());
              entries.sort((a, b) => b[1] - a[1]);
              const topCount = entries[0][1];
              const tied = entries.filter((e) => e[1] === topCount).map((e) => e[0]);
              if (tied.length === 1) replacement = tied[0];
              else {
                const roll = n2(seedU32, 19000 + x, 19100 + y);
                replacement = tied[Math.floor(roll * tied.length)];
              }
            } else {
              const roll = n2(seedU32, 19200 + x, 19300 + y);
              const w2 = { ...weights };
              delete w2.water;
              delete w2.settlement;
              const total = Object.values(w2).reduce((a, b) => a + b, 0) || 1;
              for (const k in w2) w2[k] /= total;
              replacement = pickByWeights(roll, w2);
            }

            next[y][x] = replacement || "plains";
          }
        }
        return next;
      }

      // Deterministic "make ranges" pass.
      function smoothMountains(seedU32, tileKeyGrid, weights, N, rounds = 2) {
        let cur = tileKeyGrid.map((row) => row.slice());

        for (let round = 0; round < rounds; round++) {
          const next = cur.map((row) => row.slice());

          for (let y = 0; y < N; y++) {
            for (let x = 0; x < N; x++) {
              const k = cur[y][x];
              if (k === "water" || k === "settlement") continue;

              const m8 = countNeighbors8Of(cur, N, x, y, "mountain");
              const roll = n2(seedU32, 54000 + round * 1000 + x, 54100 + round * 1000 + y);

              if (k === "mountain") {
                if (m8 < 2 && roll < 0.8) {
                  const w2 = { ...weights };
                  delete w2.water;
                  delete w2.settlement;
                  delete w2.mountain;
                  const total = Object.values(w2).reduce((a, b) => a + b, 0) || 1;
                  for (const kk in w2) w2[kk] /= total;
                  next[y][x] = pickByWeights(roll, w2);
                }
              } else {
                if (m8 >= 5 && roll < 0.65) next[y][x] = "mountain";
                else if (m8 === 4 && roll < 0.25) next[y][x] = "mountain";
              }
            }
          }

          cur = next;
        }

        return cur;
      }

      /* ====================== Water depth via distance-to-land + smoothing ====================== */
      function waterGlyph(depth) {
        return tileset.water.depthGlyphs[depth] || tileset.water.depthGlyphs[1] || "~";
      }

      function distToNonWater(tileKeyGrid, N) {
        const INF = 1e9;
        const dist = Array.from({ length: N }, () => Array(N).fill(INF));

        const qx = new Int16Array(N * N);
        const qy = new Int16Array(N * N);
        let head = 0,
          tail = 0;

        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "water") {
              dist[y][x] = 0;
              qx[tail] = x;
              qy[tail] = y;
              tail++;
            }
          }
        }

        while (head < tail) {
          const x = qx[head],
            y = qy[head];
          head++;
          const d = dist[y][x];

          for (const [nx, ny] of neighbors4(N, x, y)) {
            if (dist[ny][nx] > d + 1) {
              dist[ny][nx] = d + 1;
              qx[tail] = nx;
              qy[tail] = ny;
              tail++;
            }
          }
        }

        return dist;
      }

      function smoothDepthsTodo2(seedU32, tileKeyGrid, depthGrid, N) {
        const next = depthGrid.map((row) => row.slice());

        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "water") continue;
            if (next[y][x] <= 1) continue;

            let hasPlains = false;
            for (const [nx, ny] of neighbors4(N, x, y)) {
              if (tileKeyGrid[ny][nx] === "plains") {
                hasPlains = true;
                break;
              }
            }
            if (!hasPlains) continue;

            const roll = n2(seedU32, 61000 + x, 61100 + y);
            if (roll < 0.75) next[y][x] = 1;
          }
        }

        const next2 = next.map((row) => row.slice());
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "water") continue;
            if (next[y][x] !== 3) continue;

            let touches1 = false;
            for (const [nx, ny] of neighbors4(N, x, y)) {
              if (tileKeyGrid[ny][nx] === "water" && next[ny][nx] === 1) {
                touches1 = true;
                break;
              }
            }
            if (!touches1) continue;

            const roll = n2(seedU32, 62000 + x, 62100 + y);
            if (roll < 0.5) next2[y][x] = 2;
          }
        }

        return next2;
      }

      function buildDepthGrid(seedU32, tileKeyGrid, river, N) {
        const dist = distToNonWater(tileKeyGrid, N);

        const depthGrid = Array.from({ length: N }, () => Array(N).fill(0));
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "water") continue;
            let d = clamp(dist[y][x], 1, 3);
            if (river?.has(`${x},${y}`)) d = Math.max(d, 2);
            depthGrid[y][x] = d;
          }
        }

        return smoothDepthsTodo2(seedU32, tileKeyGrid, depthGrid, N);
      }

      /* ====================== Mountain height via distance-to-non-mountain ====================== */
      function distToNonMountain(tileKeyGrid, N) {
        const INF = 1e9;
        const dist = Array.from({ length: N }, () => Array(N).fill(INF));

        const qx = new Int16Array(N * N);
        const qy = new Int16Array(N * N);
        let head = 0,
          tail = 0;

        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "mountain") {
              dist[y][x] = 0;
              qx[tail] = x;
              qy[tail] = y;
              tail++;
            }
          }
        }

        while (head < tail) {
          const x = qx[head],
            y = qy[head];
          head++;
          const d = dist[y][x];

          for (const [nx, ny] of neighbors4(N, x, y)) {
            if (dist[ny][nx] > d + 1) {
              dist[ny][nx] = d + 1;
              qx[tail] = nx;
              qy[tail] = ny;
              tail++;
            }
          }
        }
        return dist;
      }

      function buildHeightGrid(tileKeyGrid, N) {
        const dist = distToNonMountain(tileKeyGrid, N);
        const heightGrid = Array.from({ length: N }, () => Array(N).fill(0));
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] !== "mountain") continue;
            const d = dist[y][x];
            const h = 1 + Math.floor((d - 1) * 1.6);
            heightGrid[y][x] = clamp(h, 1, 5);
          }
        }
        return heightGrid;
      }

      function mountainGlyph(h) {
        return tileset.mountain.height[h] || tileset.mountain.height[1] || "^";
      }

      /* ====================== Forest typing (biome + climate) ====================== */
      function forestTypeForCell(seedU32, x, y, biome, climate) {
        const s = String(biome || "").toLowerCase();
        const tempTier = clamp(climate?.tempTier ?? 4, 1, 8);
        const rainIdx = clamp((climate?.rainIdx ?? 3) + 1, 1, 8);

        const isDeadBiome =
          s.includes("desert") ||
          s.includes("badland") ||
          s.includes("barren") ||
          s.includes("ash") ||
          s.includes("irradiat") ||
          s.includes("scrapyard") ||
          s.includes("ruin") ||
          s.includes("ruined") ||
          s.includes("wasteland") ||
          s.includes("lava");

        const isColdBiome = s.includes("tundra") || s.includes("taiga") || s.includes("ice") || s.includes("highland");

        if (isDeadBiome) {
          const roll = n2(seedU32, 70000 + x, 70100 + y);
          if (rainIdx >= 6 && roll < 0.18) return "deciduous";
          return "dead";
        }

        if (isColdBiome || tempTier <= 3) return "coniferous";

        if (tempTier >= 7 && rainIdx <= 2) {
          const roll = n2(seedU32, 70200 + x, 70300 + y);
          return roll < 0.6 ? "dead" : "deciduous";
        }

        if (rainIdx >= 6 && tempTier >= 5) return "deciduous";

        const roll = n2(seedU32, 70400 + x, 70500 + y);
        return roll < 0.18 ? "coniferous" : "deciduous";
      }

      function forestGlyphForType(ft, seed01) {
        const t = tileset.forest;
        const list = ft === "coniferous" ? t.coniferous : ft === "dead" ? t.dead : ft === "deciduous" ? t.deciduous : t.variants;
        const idx = Math.floor(seed01 * list.length);
        return list[idx] || t.tile;
      }

      /* ====================== Map generator ====================== */
      function genMap(seedU32, biome, tileset, worldMeta = null, climate = null) {
        const N = 25;
        const weights = tileWeightsForBiome(biome);

        const river = biomeAllowsRiver(biome) && n2(seedU32, 42000, 43000) > 0.35 ? riverCells(seedU32 ^ 0x9e3779b9, N) : new Set();

        let tileKeyGrid = Array.from({ length: N }, () => Array(N).fill("plains"));

        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            let tileKey;
            if (river.has(`${x},${y}`)) {
              tileKey = "water";
            } else {
              const r0 = n2(seedU32, x, y);
              tileKey = pickByWeights(r0, weights);
              if (tileKey !== "water" && n2(seedU32, 7000 + x, 8000 + y) > 0.985) tileKey = "settlement";
            }
            tileKeyGrid[y][x] = tileKey;
          }
        }

        tileKeyGrid = cleanupIsolatedWater(seedU32, tileKeyGrid, weights, N);
        tileKeyGrid = smoothMountains(seedU32, tileKeyGrid, weights, N, 2);
        if (biome.toLowerCase().includes("desert")) {
          const desertAll = n2(seedU32, 4242, 31337) < 0.5;
          if (desertAll) {
            for (let y = 0; y < N; y++) {
              for (let x = 0; x < N; x++) {
                if (tileKeyGrid[y][x] === "plains") tileKeyGrid[y][x] = "desert";
              }
            }
          }
        }

        const depthGrid = buildDepthGrid(seedU32, tileKeyGrid, river, N);
        const heightGrid = buildHeightGrid(tileKeyGrid, N);

        const forestTypeGrid = Array.from({ length: N }, () => Array(N).fill(null));
        for (let y = 0; y < N; y++) {
          for (let x = 0; x < N; x++) {
            if (tileKeyGrid[y][x] === "forest") forestTypeGrid[y][x] = forestTypeForCell(seedU32, x, y, biome, climate);
          }
        }

        const ann = worldMeta?.annotations || new Map();

        let s = "";
        for (let y = 0; y < N; y++) {
          let row = "";
          for (let x = 0; x < N; x++) {
            const tileKey = tileKeyGrid[y][x];
            const key = `${x},${y}`;
            const a = ann.get(key);

            const bits = [];
            bits.push(`${tileKey} @ (${x},${y})`);
            if (tileKey === "water") bits.push(`depth: ${clamp(depthGrid[y][x] || 1, 1, 3)}`);
            if (tileKey === "mountain") bits.push(`height: ${clamp(heightGrid[y][x] || 1, 1, 5)}`);
            if (tileKey === "forest") bits.push(`forest: ${forestTypeGrid[y][x] || "mixed"}`);
            if (a?.settlementName) bits.push(`Settlement: ${a.settlementName}`);
            if (a?.fieldCamp) bits.push("Field Camp");
            if (a?.poi?.length) for (const p of a.poi) bits.push(`POI: ${p.name} [${p.type}]`);
            if (a?.factions?.length) for (const f of a.factions) bits.push(`Faction: ${f.name}`);
            if (a?.npcs?.length) for (const n of a.npcs) bits.push(`NPC: ${n.name} â€” ${n.task}`);

            const title = escAttr(bits.join("\n"));

            if (a?.fieldCamp) {
              const ch = tileset.camp?.tile || "á—‘";
              row += `<span data-cell="${x},${y}" data-tile="camp" title="${title}">${ch}</span>`;
            } else if (tileKey === "water") {
              const d = clamp(depthGrid[y][x] || 1, 1, 3);
              const ch = waterGlyph(d);
              row += `<span data-cell="${x},${y}" data-tile="water" data-depth="${d}" title="${title}">${ch}</span>`;
            } else if (tileKey === "mountain") {
              const h = clamp(heightGrid[y][x] || 1, 1, 5);
              const ch = mountainGlyph(h);
              row += `<span data-cell="${x},${y}" data-tile="mountain" data-height="${h}" title="${title}">${ch}</span>`;
            } else if (tileKey === "forest") {
              const ft = forestTypeGrid[y][x] || "mixed";
              const variantSeed = n2(seedU32, x + 999, y + 999);
              const ch = forestGlyphForType(ft, variantSeed);
              row += `<span data-cell="${x},${y}" data-tile="forest" data-forest="${escAttr(ft)}" title="${title}">${ch}</span>`;
            } else {
              const variantSeed = n2(seedU32, x + 999, y + 999);
              const ch = pickVariant(tileKey, tileset, variantSeed);
              row += `<span data-cell="${x},${y}" data-tile="${tileKey}" title="${title}">${ch}</span>`;
            }
          }
          s += row + (y < N - 1 ? "\n" : "");
        }

        return { html: s, tileKeyGrid, depthGrid, heightGrid, forestTypeGrid, N, river };
      }

      /* ====================== Slice Builder (minimal; unchanged behavior) ====================== */
      function coord(r) {
        const lat = (r() * 160 - 80).toFixed(2),
          lon = (r() * 360 - 180).toFixed(2);
        const NS = lat >= 0 ? "N" : "S",
          EW = lon >= 0 ? "E" : "W";
        return `${Math.abs(lat)}Â° ${NS}, ${Math.abs(lon)}Â° ${EW}`;
      }

      function resolvePlaceholders(s, ctx) {
        return s.replace(/<poi>/g, () => ctx.poi?.() ?? "site").replace(/<weather>/g, () => ctx.weather?.() ?? "weather");
      }

      function stem(s) {
        return s.replace(/^(the|a|an)\s+/i, "").split(" ")[0];
      }

      function composeHook(r, tt, ctx = {}) {
        const h1 = oneOf(r, tt.hooks);
        const m1 = maybe(r, 0.6) ? resolvePlaceholders(oneOf(r, tt.hookMods), ctx) : null;

        const hasSecond = maybe(r, 0.65);
        if (!hasSecond) return m1 ? `${h1} ${m1}.` : `${h1}.`;

        const glue = oneOf(r, tt.hookGlue);

        const h2 = (() => {
          let v;
          let guard = 0;
          do {
            v = oneOf(r, tt.hooks);
          } while ((v === h1 || stem(v) === stem(h1)) && guard++ < 5);
          return v;
        })();

        const m2 = maybe(r, 0.6) ? resolvePlaceholders(oneOf(r, tt.hookMods), ctx) : null;

        let left = m1 ? `${h1} ${m1}` : h1;
        const right = m2 ? `${h2} ${m2}` : h2;

        left = left.charAt(0).toUpperCase() + left.slice(1);
        return `${left}, ${glue} ${right}.`;
      }

      function composeMotive(r, tt, { adjChance = 0.6, forceAdj = false, normalizeSpacing = true } = {}) {
        const motive = oneOf(r, tt.motives);
        const glue = oneOf(r, tt.motiveGlue);
        const includeAdj = forceAdj || maybe(r, adjChance);
        const adj = includeAdj ? oneOf(r, tt.relicAdjectives) : null;
        const noun = oneOf(r, tt.relicNouns);

        let line = `${motive} ${glue} ${adj ? adj + " " : ""}${noun}`;
        if (normalizeSpacing) line = line.replace(/\s{2,}/g, " ").trim();
        return line;
      }

      function buildSlice(seedStr, theme) {
        const base = h32(String(seedStr));
        const r = xs32(base);
        const tt = T[theme] || T.fantasy;
        const npcR = xs32(base ^ 0x52dce729);
        const npcGen = new NameGenerator(npcR);
        const npcCount = 2 + ((npcR() * 3) | 0);

        const toponyms = buildToponyms(r, 20);
        const region = buildRegionsFromToponyms(r, toponyms, 1)[0];

        const biome = oneOf(r, tt.biome);
        const tempPick = pickTempTier(r, tt);
        const rainPick = pickRainIndex(r, tt);
        const climA = oneOf(r, tt.climateAdj);
        const coords = coord(r);

        const climate = { tempTier: tempPick.tier, tempLabel: tempPick.label, rainIdx: rainPick.idx, rainLabel: rainPick.label, adj: climA };

        const fCount = 1 + ((r() * 3) | 0);
        const pCount = 2 + ((r() * 3) | 0);

        const factions = [];
        for (let i = 0; i < fCount; i++) {
          const motive = composeMotive(r, tt);
          const name = factionName(r, theme);
          factions.push({ name, motive });
        }

        const poiTypes = [];
        for (let i = 0; i < pCount; i++) poiTypes.push(oneOf(r, tt.pois));

        const weatherNow = oneOf(r, tt.weather);

        const mapSeed = h32(seedStr + "|map|" + theme);
        const map0 = genMap(mapSeed, biome, tileset, null, climate);
        const landCells = [];
        for (let y = 0; y < map0.N; y++) {
          for (let x = 0; x < map0.N; x++) {
            if (map0.tileKeyGrid[y][x] !== "water") landCells.push(`${x},${y}`);
          }
        }
        const worldMeta = placeWorldRefs(mapSeed, theme, map0.tileKeyGrid, map0.N, poiTypes, factions, r);
        const settlementEntries = Array.from(worldMeta.settlementNameByCell.entries());
        const poiNames = worldMeta.poiPlacements.map((p) => p.poiName);
        const npcLocationKinds = Object.keys(NPC_TASKS);
        const npcs = [];
        const seenNpcNames = new Set();
        let guard = 0;

        function pickLandCell() {
          return landCells[(npcR() * landCells.length) | 0] || "0,0";
        }

        function npcLocationFor(kind) {
          if (kind === "faction") {
            const pick = oneOf(npcR, worldMeta.factionPlacements);
            if (pick) return { prep: "with", label: pick.factionName, cell: pick.cell };
          }
          if (kind === "settlement" && settlementEntries.length) {
            const [cell, name] = settlementEntries[(npcR() * settlementEntries.length) | 0];
            return { prep: "in", label: name, cell };
          }
          return { prep: "out in", label: "the wilds", cell: pickLandCell() };
        }

        function npcPoiName() {
          if (poiNames.length) return oneOf(npcR, poiNames);
          return oneOf(npcR, tt.pois || ["site"]);
        }

        while (npcs.length < npcCount && guard++ < npcCount * 20) {
          const name = npcGen.npcName();
          if (seenNpcNames.has(name)) continue;
          seenNpcNames.add(name);
          const kind = npcLocationKinds[(npcR() * npcLocationKinds.length) | 0];
          const taskTemplate = oneOf(npcR, NPC_TASKS[kind]);
          const taskPoi = npcPoiName();
          const task = resolvePlaceholders(taskTemplate, { poi: () => taskPoi, weather: () => weatherNow });
          const loc = npcLocationFor(kind);
          npcs.push({ name, task, prep: loc.prep, label: loc.label, cell: loc.cell });
        }

        for (const npc of npcs) {
          let a = worldMeta.annotations.get(npc.cell);
          if (!a) {
            a = { poi: [], factions: [] };
            worldMeta.annotations.set(npc.cell, a);
          }
          if (!a.npcs) a.npcs = [];
          a.npcs.push({ name: npc.name, task: npc.task });
        }

        const map1 = genMap(mapSeed, biome, tileset, worldMeta, climate);
        const hookPick = oneOf(r, worldMeta.poiPlacements);
        const hookPOIName = hookPick ? hookPick.poiName : oneOf(r, tt.pois || ["facility"]);
        const hookPOICell = hookPick ? hookPick.cell : null;

        const hook = composeHook(r, tt, { poi: () => hookPOIName, weather: () => oneOf(r, tt.weather || ["light wind"]) });

        let hookHtml = escHtml(hook);
        if (hookPick && hookPOIName) {
          const re = new RegExp(escRe(hookPOIName), "g");
          hookHtml = hookHtml.replace(re, xref(hookPOICell, hookPOIName));
        }

        let html = "";
        html += `Theme  : ${escHtml(theme)}\n`;
        html += `Region : ${escHtml(region)}\n`;
        html += `Biome  : ${escHtml(biome)}\n`;
        html += `Coords : ${escHtml(coords)}\n`;
        html += `Climate: ${escHtml(tempPick.label)}, ${escHtml(rainPick.label)}, ${escHtml(climA)}\n`;
        html += `Current Weather: ${escHtml(weatherNow)}\n\n`;

        html += `Factions (${factions.length}):\n`;
        worldMeta.factionPlacements.forEach((fp, i) => {
          const baseAnn = worldMeta.annotations.get(fp.cell);
          const baseName = baseAnn?.settlementName ? baseAnn.settlementName : "Field Camp";
          html += `  ${i + 1}. ${xref(fp.cell, fp.factionName)}\n`;
          html += `\t- ${escHtml(fp.motive)}\n`;
          html += `\t- Base: ${xref(fp.cell, baseName)} @ (${escHtml(fp.cell)})\n\n`;
        });

        html += `NPCs (${npcs.length}):\n`;
        npcs.forEach((npc) => {
          html += `  - ${escHtml(npc.name)}: ${escHtml(npc.task)} ${escHtml(npc.prep)} ${xref(npc.cell, npc.label)}\n`;
        });
        html += "\n";

        html += `Points of Interest (${worldMeta.poiPlacements.length}):\n`;
        worldMeta.poiPlacements.forEach((p) => {
          const a = worldMeta.annotations.get(p.cell);
          const near = a?.settlementName ? `, near ${xref(p.cell, a.settlementName)}` : "";
          html += `  - ${xref(p.cell, p.poiName)}${near} @ (${escHtml(p.cell)})\n`;
        });

        html += `\nHook: ${hookHtml}\n`;

        return { html, mapGrid: map1.html };
      }

      /* ====================== State, Storage, UI ====================== */
      const $ = (sel) => document.querySelector(sel);
      const out = $("#out"),
        mapEl = $("#map"),
        seedIn = $("#seed"),
        seedShow = $("#seedShow"),
        themeSel = $("#theme");

      const btnGen = $("#gen"),
        btnSave = $("#save"),
        btnPrev = $("#prev"),
        btnNext = $("#next");

      const btnCopySeed = $("#copySeed"),
        btnCopyOut = $("#copyOut"),
        btnShare = $("#share");

      const histList = $("#hist"),
        favList = $("#favs"),
        btnClrFav = $("#clrFav");

      const LS_H = "sow_history_v2",
        LS_F = "sow_faves_v2",
        MAXH = 5;

      let histArr = [],
        faves = [],
        idx = -1,
        current = "";

      function loadLS() {
        try {
          histArr = JSON.parse(localStorage.getItem(LS_H) || "[]");
          faves = JSON.parse(localStorage.getItem(LS_F) || "[]");
        } catch (e) {
          histArr = [];
          faves = [];
        }
      }

      function saveLS() {
        localStorage.setItem(LS_H, JSON.stringify(histArr.slice(-MAXH)));
        localStorage.setItem(LS_F, JSON.stringify([...new Set(faves)]));
      }

      function renderLists() {
        if (!histList || !favList) return;

        histList.innerHTML = "";
        const recent = histArr.slice(-MAXH).slice().reverse();
        recent.forEach((s) => {
          const li = document.createElement("li");
          li.textContent = s;
          li.title = "Load seed";
          li.onclick = () => {
            setCurrentSeed(s, true);
            generate();
          };
          histList.appendChild(li);
        });

        favList.innerHTML = "";
        faves.forEach((s) => {
          const li = document.createElement("li");
          li.textContent = s;
          li.title = "Load favorite";
          li.onclick = () => {
            setCurrentSeed(s, true);
            generate();
          };
          favList.appendChild(li);
        });
      }

      function pushHistory(s) {
        if (!s) return;
        if (histArr.length === 0 || histArr[histArr.length - 1] !== s) histArr.push(s);
        if (histArr.length > MAXH) histArr = histArr.slice(-MAXH);
        idx = histArr.length - 1;
        saveLS();
        renderLists();
      }

      function navigate(d) {
        if (!histArr.length) return;
        idx = Math.max(0, Math.min(histArr.length - 1, idx + d));
        setCurrentSeed(histArr[idx], false);
        generate();
      }

      function setCurrentSeed(s, push = true) {
        current = s;
        seedShow.textContent = s;
        if (push) pushHistory(s);
        updateHash();
      }

      function parseHash() {
        const h = location.hash.replace(/^#/, "");
        const params = new URLSearchParams(h.includes("=") ? h : "");
        const s = params.get("s"),
          t = params.get("t");
        return { s: s ? decodeURIComponent(s) : null, t: t ? decodeURIComponent(t) : null };
      }

      function updateHash() {
        if (!current) return;
        const t = themeSel.value;
        const h = `s=${encodeURIComponent(current)}&t=${encodeURIComponent(t)}`;
        if (location.hash !== `#${h}`) window.history.replaceState(null, "", `#${h}`);
      }

      function resolveTheme(seed, sel) {
        if (sel !== "rnd") return sel;
        const keys = Object.keys(T);
        return keys[h32(seed) % keys.length];
      }

      function doGenerate() {
        const typed = seedIn.value.trim();
        const s = typed || randSeed();
        setCurrentSeed(s, true);
        generate();
      }

      /* ====================== Cross-hover binding ====================== */
      let _crossHoverBound = false;

      function bindCrossHover() {
        if (_crossHoverBound) return;
        _crossHoverBound = true;

        const clearHot = () => {
          document.querySelectorAll(".is-hot").forEach((el) => el.classList.remove("is-hot"));
        };

        const markCell = (cell) => {
          clearHot();
          if (!cell) return;

          const esc = window.CSS && CSS.escape ? CSS.escape(cell) : cell.replace(/"/g, '\\"');

          mapEl.querySelectorAll(`span[data-cell="${esc}"]`).forEach((el) => el.classList.add("is-hot"));
          out.querySelectorAll(`.xref[data-cell="${esc}"]`).forEach((el) => el.classList.add("is-hot"));
        };

        out.addEventListener("pointerover", (e) => {
          const t = e.target.closest?.(".xref[data-cell]");
          if (!t) return;
          markCell(t.dataset.cell);
        });

        out.addEventListener("pointerout", (e) => {
          const t = e.target.closest?.(".xref[data-cell]");
          if (!t) return;
          const rt = e.relatedTarget;
          if (rt && rt.closest?.(".xref[data-cell]")) return;
          clearHot();
        });

        mapEl.addEventListener("pointerover", (e) => {
          const t = e.target.closest?.("span[data-cell]");
          if (!t) return;
          markCell(t.dataset.cell);
        });

        mapEl.addEventListener("pointerout", (e) => {
          const t = e.target.closest?.("span[data-cell]");
          if (!t) return;
          const rt = e.relatedTarget;
          if (rt && rt.closest?.("span[data-cell]")) return;
          clearHot();
        });
      }

      function generate() {
        if (!current) return;
        const themeUsed = resolveTheme(current, themeSel.value);
        const { html, mapGrid } = buildSlice(current, themeUsed);
        out.innerHTML = html;
        mapEl.innerHTML = mapGrid;
        bindCrossHover();
      }

      function shareURL() {
        if (!current) return;
        updateHash();
      }

      /* ====================== Wire up ====================== */
      btnGen.onclick = doGenerate;
      seedIn.addEventListener("keydown", (e) => {
        if (e.key === "Enter") doGenerate();
      });
      btnPrev.onclick = () => navigate(-1);
      btnNext.onclick = () => navigate(1);

      btnSave.onclick = () => {
        if (!current) return;
        if (!faves.includes(current)) faves.push(current);
        saveLS();
        renderLists();
      };

      btnCopySeed.onclick = () => {
        if (current) navigator.clipboard?.writeText(current);
      };

      btnCopyOut.onclick = () => navigator.clipboard?.writeText((out.textContent || "") + "\n" + (mapEl.textContent || ""));

      btnShare.onclick = () => shareURL();

      if (btnClrFav) {
        btnClrFav.onclick = () => {
          if (!faves.length) return;
          if (!confirm("Clear all favorites?")) return;
          faves = [];
          saveLS();
          renderLists();
        };
      }

      themeSel.onchange = () => {
        generate();
        updateHash();
      };

      window.addEventListener("hashchange", () => {
        const { s, t } = parseHash();
        if (t) themeSel.value = t;
        if (s) {
          setCurrentSeed(s, true);
          generate();
        }
      });

      (function init() {
        loadLS();
        renderLists();
        const { s, t } = parseHash();
        if (t) themeSel.value = t;

        if (s) {
          setCurrentSeed(s, true);
        } else if (histArr.length) {
          setCurrentSeed(histArr[histArr.length - 1], false);
          idx = histArr.length - 1;
        } else {
          setCurrentSeed(randSeed(), true);
        }
        generate();
      })();
    </script>
  </body>
</html>
